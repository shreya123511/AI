# -*- coding: utf-8 -*-
"""ShreyaJoshi_Worksheet - 0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12Y__6Fe-FYfCRVfuwYxf6gUc54u6vLeB
"""

time_data = [
(3.5, 2.0, 7.0), (5.0, 1.5, 6.5), (2.5, 3.0, 8.0),
(4.0, 2.0, 6.0), (1.5, 4.5, 9.0), (3.0, 2.5, 7.5),
(5.5, 1.0, 6.0), (2.0, 3.5, 8.5), (4.5, 2.0, 7.0),
(3.0, 3.0, 7.5), (6.0, 1.5, 6.0), (2.5, 4.0, 8.0),
(4.0, 2.5, 7.0), (5.0, 2.0, 6.5), (3.5, 2.5, 7.0)
]
low = []
moderate = []
high = []
for study, entertainment, sleep in time_data:
    if study < 3:
        low.append(study)
    elif 3 <= study <= 5:
        moderate.append(study)
    else:
        high.append(study)
print("Low:", low)
print("Moderate:", moderate)
print("High:", high)

num_low = len(low)
num_moderate = len(moderate)
num_high = len(high)

print(f"Number of days with low study time (<3 hours): {num_low}")
print(f"Number of days with moderate study time (3-5 hours): {num_moderate}")
print(f"Number of days with high study time (>5 hours): {num_high}")

study_minutes = []
for study, entertainment, sleep in time_data:
    study_minutes.append(study * 60)

print("Study hours converted to minutes:", study_minutes)

study_hours = []
entertainment_hours = []
sleep_hours = []

for study, entertainment, sleep in time_data:
    study_hours.append(study)
    entertainment_hours.append(entertainment)
    sleep_hours.append(sleep)

average_study = sum(study_hours) / len(study_hours)
average_entertainment = sum(entertainment_hours) / len(entertainment_hours)
average_sleep = sum(sleep_hours) / len(sleep_hours)

print(f"Average hours spent studying: {average_study:.2f}")
print(f"Average hours spent on entertainment: {average_entertainment:.2f}")
print(f"Average hours spent sleeping: {average_sleep:.2f}")

import matplotlib.pyplot as plt

plt.figure(figsize=(8, 6))
plt.scatter(study_hours, sleep_hours, color='blue', alpha=0.7)
plt.title('Study Hours vs. Sleep Hours')
plt.xlabel('Study Hours')
plt.ylabel('Sleep Hours')
plt.grid(True)
plt.show()

def factorial(n):
    """
    Calculate the factorial of a non-negative integer n using recursion.

    Args:
        n (int): A non-negative integer

    Returns:
        int: The factorial of n

    Raises:
        ValueError: If n is negative
    """
    if n < 0:
        raise ValueError("Factorial is not defined for negative numbers.")
    elif n == 0:
        return 1
    else:
        return n * factorial(n - 1)

print("Factorial of 5:", factorial(5))
print("Factorial of 0:", factorial(0))

def generate_permutations(s):
    """
    Generate all unique permutations of a string using recursion.

    Args:
        s (str): Input string

    Returns:
        list: List of unique permutations
    """
    if len(s) == 1:
        return [s]

    permutations = set()
    for i in range(len(s)):
        fixed_char = s[i]
        remaining = s[:i] + s[i+1:]
        for perm in generate_permutations(remaining):
            permutations.add(fixed_char + perm)

    return list(permutations)

print(generate_permutations("abc"))
print(generate_permutations("aab"))

def calculate_directory_size(directory):
    """
    Recursively calculate the total size of a directory.

    Args:
        directory (dict): Keys are file names (int size in KB) or subdirectory names (dict).

    Returns:
        int: Total size of the directory in KB.
    """
    total_size = 0

    for name, content in directory.items():
        if isinstance(content, dict):
            total_size += calculate_directory_size(content)
        else:
            total_size += content

    return total_size

sample_directory = {
    "file1.txt": 120,
    "file2.txt": 80,
    "docs": {
        "resume.docx": 200,
        "cover_letter.docx": 150,
        "projects": {
            "project1.pdf": 300,
            "project2.pdf": 250
        }
    },
    "images": {
        "photo1.jpg": 500,
        "photo2.jpg": 700
    }
}

print("Total directory size:", calculate_directory_size(sample_directory), "KB")

def longest_common_subsequence(s1, s2):
    """
    Find the length of the longest common subsequence (LCS) between two strings using DP.

    Args:
        s1 (str): First string
        s2 (str): Second string

    Returns:
        int: Length of the LCS
    """
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = 1 + dp[i-1][j-1]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[m][n]

print("LCS length of 'abcde' and 'ace':", longest_common_subsequence("abcde", "ace"))
print("LCS length of 'AGGTAB' and 'GXTXAYB':", longest_common_subsequence("AGGTAB", "GXTXAYB"))

def knapsack(weights, values, capacity):
    """
    Solve the 0/1 Knapsack problem using Dynamic Programming.

    Args:
        weights (list): List of item weights
        values (list): List of item values
        capacity (int): Maximum weight capacity

    Returns:
        int: Maximum value achievable within the given capacity
    """
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        for w in range(1, capacity + 1):
            if weights[i-1] <= w:
                include_item = values[i-1] + dp[i-1][w - weights[i-1]]
                exclude_item = dp[i-1][w]
                dp[i][w] = max(include_item, exclude_item)
            else:
                dp[i][w] = dp[i-1][w]

    return dp[n][capacity]



weights = [1, 3, 4, 5]
values = [1, 4, 5, 7]
capacity = 7

print("Maximum value achievable:", knapsack(weights, values, capacity))